var searchIndex = JSON.parse('{\
"ocaml_derive":{"doc":"<strong>This crate is not meant to be imported directly by users</strong>. …","t":[24,24,24,23],"n":["CustomType","Enum","Struct","func"],"q":["ocaml_derive","","",""],"d":["Derives implementations for <code>OCamlDesc</code> and <code>OCamlBinding</code> on …","The Enum derive macro. It generates implementations of …","The Struct derive macro. It generates implementations of …","A macro to create OCaml bindings for a function that uses …"],"i":[0,0,0,0],"f":[0,0,0,0],"p":[]},\
"ocaml_gen":{"doc":"OCaml-gen","t":[24,24,3,8,8,24,11,11,11,14,0,14,14,14,14,14,11,11,11,11,23,11,11,11,11,11,11,10,10,11,14,11,11,11,11,10],"n":["CustomType","Enum","Env","OCamlBinding","OCamlDesc","Struct","add_alias","borrow","borrow_mut","const_random","conv","decl_fake_generic","decl_func","decl_module","decl_type","decl_type_alias","default","drop","fmt","from","func","get_type","into","nested","new","new_module","new_type","ocaml_binding","ocaml_desc","parent","paste","root","try_from","try_into","type_id","unique_id"],"q":["ocaml_gen","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"d":["Derives implementations for <code>OCamlDesc</code> and <code>OCamlBinding</code> on …","The Enum derive macro. It generates implementations of …","The environment at some point in time during the …","<code>OCamlBinding</code> is the trait implemented by types to generate …","<code>OCamlDesc</code> is the trait implemented by types to facilitate …","The Struct derive macro. It generates implementations of …","Adds a new alias for the current scope (module).","","","Random constants","Implementations of <code>crate::OCamlDesc</code> for types that have …","Creates a fake generic. This is a necessary hack, at the …","Declares the binding for a given function","Creates a module","Declares the binding for a given type","Declares a new OCaml type that is made of other types","","This makes sure that we close our OCaml modules (with the …","","Returns the argument unchanged.","A macro to create OCaml bindings for a function that uses …","Retrieves a type that was declared previously.","Calls <code>U::from(self)</code>.","how deeply nested are we currently? (default is 0)","Creates a new environment.","Create a module and enters it.","Declares a new type. If the type was already declared, …","will generate the OCaml bindings for a type (called root …","describes the type in OCaml, given the current environment …","called when we exit a module","","you can call this to go back to the root and finalize the …","","","","Returns a unique ID for the type. This ID will not change …"],"i":[0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,1,1,12,13,1,0,1,1,1,1,13],"f":[0,0,0,0,0,0,[[1,2,3]],[[]],[[]],0,0,0,0,0,0,0,[[],1],[1],[[1,4],5],[[]],0,[[1,2,3],6],[[]],[1,7],[[],1],[[1,3],6],[[1,2,3]],[[1,[8,[3]],9],6],[1,6],[1,6],0,[1,6],[[],10],[[],10],[[],11],[[],2]],"p":[[3,"Env"],[15,"u128"],[15,"str"],[3,"Formatter"],[6,"Result"],[3,"String"],[15,"usize"],[4,"Option"],[15,"bool"],[4,"Result"],[3,"TypeId"],[8,"OCamlBinding"],[8,"OCamlDesc"]]}\
}');
if (typeof window !== 'undefined' && window.initSearch) {window.initSearch(searchIndex)};
if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};
