searchState.loadedDescShard("ocaml_gen", 0, "OCaml-gen\nDerives implementations for <code>OCamlDesc</code> and <code>OCamlBinding</code> on …\nThe Enum derive macro. It generates implementations of …\nThe environment at some point in time during the …\n<code>OCamlBinding</code> is the trait implemented by types to generate …\n<code>OCamlDesc</code> is the trait implemented by types to facilitate …\nThe Struct derive macro. It generates implementations of …\nAdds a new alias for the current scope (module).\nImplementations of <code>crate::OCamlDesc</code> for types that have …\nCreates a fake generic. This is a necessary hack, at the …\nDeclares the binding for a given function\nCreates a module\nDeclares the binding for a given type\nDeclares a new OCaml type that is made of other types\nThis makes sure that we close our OCaml modules (with the …\nReturns the argument unchanged.\nA macro to create OCaml bindings for a function that uses …\nRetrieves a type that was declared previously. A boolean …\nCalls <code>U::from(self)</code>.\nhow deeply nested are we currently? (default is 0)\nCreates a new environment.\nCreate a module and enters it.\nDeclares a new type. If the type was already declared, …\nwill generate the OCaml bindings for a type (called root …\ndescribes the type in OCaml, given the current environment …\ncalled when we exit a module\nTo use the library, you can simply import the prelude as …\nyou can call this to go back to the root and finalize the …\nReturns a unique ID for the type. This ID will not change …\nCreates a fake generic. This is a necessary hack, at the …\nDeclares the binding for a given function\nCreates a module\nDeclares the binding for a given type\nDeclares a new OCaml type that is made of other types")